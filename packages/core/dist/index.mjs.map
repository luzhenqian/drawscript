{"version":3,"sources":["../generator.ts","../tokenize.ts","../index.ts"],"sourcesContent":["import { Token, Tokens } from \"./tokenize\";\n\nfunction generator(tokens: Tokens) {\n  let i = 0; // è·Ÿè¸ªä»£ç ä½ç½®\n  let out = \"\"; // è¾“å‡ºä»£ç \n  let addCode = (code: string) => (out += `${code}\\n`); // æ·»åŠ ä»£ç \n  // å’Œåˆ†è¯å™¨å¥—è·¯ä¸€æ ·\n  while (i < tokens.length) {\n    const token: () => Token = () => tokens[i]; // å½“å‰è¯ä»¤ç‰Œ\n    switch (token().type) {\n      case \"START\":\n        addCode(\"__ds__.start()\");\n        break;\n      case \"END\":\n        addCode(\"__ds__.end()\");\n        break;\n      case \"NAME\":\n        /**\n         * å¦‚æœæ˜¯ r position å‡½æ•°\n         */\n        if (token().value === \"r\") {\n          expect(tokens[++i].type, \"PARAMETERS_START\");\n          const params: number[][] = []; // å­˜å‚¨å‚æ•°\n          let param: number[] = [];\n          // æ‹¼æ¥å‚æ•°\n          while (token().type !== \"PARAMETERS_END\") {\n            if (token().type === \"NUMBER\") {\n              param.push(Number(token().value));\n            }\n            if (\n              tokens[i + 1].type === \"PARAMETERS_SEPARATOR\" ||\n              tokens[i + 1].type === \"PARAMETERS_END\"\n            ) {\n              params.push(param);\n              param = [];\n            }\n            i++;\n          }\n          addCode(`__ds__.rect(...${JSON.stringify(params)});`);\n        } else if (token().value === \"c\") {\n          /**\n           * å¦‚æœæ˜¯ cï¼Œæ‰§è¡Œ color å‡½æ•°\n           */\n          expect(tokens[++i].type, \"PARAMETERS_START\");\n          const params: string[] = []; // å­˜å‚¨å‚æ•°\n          // æ‹¼æ¥å‚æ•°\n          while (token().type !== \"PARAMETERS_END\") {\n            if (token().type === \"NAME\" || token().type === \"NUMBER\") {\n              params.push(token().value);\n            }\n            i++;\n          }\n          addCode(`__ds__.color(\"${params.join(\"\")}\");`);\n        } else {\n          throw new Error(`Unknown name: ${token().value}`); // ğŸ¤¬ Error\n        }\n        break;\n    }\n    i++;\n  }\n  return out;\n}\n\nfunction expect(t1: string, t2: string) {\n  if (t1 !== t2) {\n    throw new Error(`Expected ${t2}, got ${t1}`);\n  }\n}\n\nexport { generator, expect };\n","export type Token = {\n  type: string;\n  value: string;\n};\n\nexport type Tokens = Token[];\n\nfunction tokenize(code: string) {\n  const tokens: Tokens = []; // è¯ä»¤ç‰Œ\n  let i = 0; // è·Ÿè¸ªä»£ç ä½ç½®\n\n  // å‘ token ä¸­åŠ è¯ä»¤ç‰Œ\n  const addToken = (type: string, value: string) =>\n    tokens.push({ type, value });\n\n  // å¼€å¯å¾ªç¯ éå†ä»£ç \n  while (i < code.length) {\n    const char = code[i]; // å½“å‰å­—ç¬¦\n    switch (char) {\n      // å¿½ç•¥ç©ºç™½å­—ç¬¦\n      case \" \":\n      case \"\\t\":\n      case \"\\n\":\n      case \"\\r\":\n        i++;\n        break;\n      // å¦‚æœæ˜¯ <ï¼Œæ·»åŠ ä¸€ä¸ª START ç±»å‹çš„è¯ä»¤ç‰Œ\n      case \"<\":\n        addToken(\"START\", char);\n        i++;\n        break;\n      // å¦‚æœæ˜¯ >ï¼Œæ·»åŠ ä¸€ä¸ª END ç±»å‹çš„è¯ä»¤ç‰Œ\n      case \">\":\n        addToken(\"END\", char);\n        i++;\n        break;\n      // å¦‚æœæ˜¯ (ï¼Œæ·»åŠ ä¸€ä¸ª PARAMETERS_START ç±»å‹çš„è¯ä»¤ç‰Œ\n      case \"(\":\n        addToken(\"PARAMETERS_START\", char);\n        i++;\n        break;\n      // å¦‚æœæ˜¯ ,ï¼Œæ·»åŠ ä¸€ä¸ª PARAMETERS_SEPARATOR ç±»å‹çš„è¯ä»¤ç‰Œ\n      case \",\":\n        addToken(\"PARAMETERS_SEPARATOR\", char);\n        i++;\n        break;\n      // å¦‚æœæ˜¯ )ï¼Œæ·»åŠ ä¸€ä¸ª PARAMETERS_END ç±»å‹çš„è¯ä»¤ç‰Œ\n      case \")\":\n        addToken(\"PARAMETERS_END\", char);\n        i++;\n        break;\n      // é™¤äº†ä¸Šè¿°æƒ…å†µå¤–ï¼Œæˆ‘ä»¬å¼€å§‹æ£€æŸ¥å®ƒä»¬æ˜¯å…³é”®å­—è¿˜æ˜¯æ•°å­—\n      default: // æ˜¯å¦æ˜¯æ•°å­—\n        // æ˜¯å¦æ˜¯å­—æ¯æˆ–è€…åå…­è¿›åˆ¶é¢œè‰²\n        const isDigit = /\\d|\\./.test(char);\n        const isLetter = /([a-z])|#/i.test(char);\n\n        // å¤„ç†æ•°å­—çš„é€»è¾‘\n        if (isDigit) {\n          let number = \"\"; // æ‹¼æ¥å­˜å‚¨æ•°å­—\n          while (i < code.length && /\\d|\\./.test(code[i])) {\n            // å¾ªç¯ï¼Œç›´åˆ°ä¸æ˜¯æ•°å­—æˆ–è€…åå…­è¿›åˆ¶é¢œè‰²\n            number += code[i];\n            i++;\n          }\n          addToken(\"NUMBER\", number); // æ·»åŠ æ•°å­—è¯ä»¤ç‰Œ\n        } else if (isLetter) {\n          let name = \"\"; // æ‹¼æ¥å­˜å‚¨å…³é”®è¯ä»¤ç‰Œ\n          while (i < code.length && /[a-z]|#/i.test(code[i])) {\n            // å¾ªç¯ï¼Œç›´åˆ°ä¸æ˜¯å­—æ¯\n            name += code[i];\n            i++;\n          }\n          addToken(\"NAME\", name); // æ·»åŠ å…³é”®è¯ä»¤ç‰Œ\n        } else {\n          throw new Error(`Unknown character: ${char}`); // ğŸ¤¬ å¦‚æœä¸æ˜¯æ•°å­—æˆ–å­—æ¯ï¼ŒæŠ›å‡ºé”™è¯¯\n        }\n        break;\n    }\n  }\n\n  // è¿”å›è¯ä»¤ç‰Œ\n  return tokens;\n}\n\nexport { tokenize };\n","import { generator } from \"./generator\";\nimport { tokenize } from \"./tokenize\";\n\nexport { tokenize } from \"./tokenize\";\nexport { generator } from \"./generator\";\n\nexport function compile(code: string) {\n  const tokens = tokenize(code);\n  const output = generator(tokens);\n  return output;\n}\n"],"mappings":"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","names":[]}